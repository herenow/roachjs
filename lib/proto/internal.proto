// Copyright 2014 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License. See the AUTHORS file
// for names of contributors.
//
// Author: Spencer Kimball (spencer.kimball@gmail.com)

package proto;

import "api.proto";
import "config.proto";
import "data.proto";
import "code.google.com/p/gogoprotobuf/gogoproto/gogo.proto";

// An InternalRangeLookupRequest is arguments to the
// InternalRangeLookup() method. It specifies the key for which the
// containing range is being requested, and the maximum number of
// total range descriptors that should be returned, if there are
// additional consecutive addressable ranges. Specify max_ranges > 1
// to pre-fill the range descriptor cache.
message InternalRangeLookupRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  optional int32 max_ranges = 2 [(gogoproto.nullable) = false];
}

// An InternalRangeLookupResponse is the return value from the
// InternalRangeLookup() method. It returns metadata for the range
// containing the requested key, optionally returning the metadata for
// additional consecutive ranges beyond the requested range to pre-fill
// the range descriptor cache.
message InternalRangeLookupResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  repeated RangeDescriptor ranges = 2 [(gogoproto.nullable) = false];
}

// An InternalHeartbeatTxnRequest is arguments to the
// InternalHeartbeatTxn() method. It's sent by transaction
// coordinators to let the system know that the transaction is still
// ongoing. Note that this heartbeat message is different from the
// heartbeat message in the gossip protocol.
message InternalHeartbeatTxnRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
}

// An InternalHeartbeatTxnResponse is the return value from the
// InternalHeartbeatTxn() method. It returns the transaction info in
// the response header. The returned transaction lets the coordinator
// know the disposition of the transaction (i.e. aborted, committed or
// pending).
message InternalHeartbeatTxnResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
}

// An InternalPushTxnRequest is arguments to the InternalPushTxn()
// method. It's sent by readers or writers which have encountered an
// "intent" laid down by another transaction. The goal is to resolve
// the conflict. Note that args.Key should be set to the txn ID of
// args.PusheeTxn, not args.Txn, as is usual. This RPC is addressed
// to the range which owns the pushee's txn record.
//
// Resolution is trivial if the txn which owns the intent has either
// been committed or aborted already. Otherwise, the existing txn can
// either be aborted (for write/write conflicts), or its commit
// timestamp can be moved forward (for read/write conflicts). The
// course of action is determined by the owning txn's status and also
// by comparing priorities.
message InternalPushTxnRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  optional Transaction pushee_txn = 2 [(gogoproto.nullable) = false];
  // Set to true to request that the PushTxn be aborted if possible.
  // This is done in the event of a writer conflicting with PusheeTxn.
  // Readers set this to false and instead attempt to move PusheeTxn's
  // commit timestamp forward.
  optional bool Abort = 3 [(gogoproto.nullable) = false];
}

// An InternalPushTxnResponse is the return value from the
// InternalPushTxn() method. It returns success and the resulting
// state of PusheeTxn if the conflict was resolved in favor of the
// caller; the caller should subsequently invoke
// InternalResolveIntent() on the conflicted key. It returns an error
// otherwise.
message InternalPushTxnResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  // Txn is non-nil if the transaction could be heartbeat and contains
  // the current value of the transaction.
  optional Transaction pushee_txn = 2;
}

// An InternalResolveIntentRequest is arguments to the
// InternalResolveIntent() method. It is sent by transaction
// coordinators and after success calling InternalPushTxn to clean up
// write intents: either to remove them or commit them.
message InternalResolveIntentRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
}

// An InternalResolveIntentResponse is the return value from the
// InternalResolveIntent() method.
message InternalResolveIntentResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
}

// An InternalSnapshotCopyRequest is arguments to the InternalSnapshotCopy()
// method. It specifies the start and end keys for the scan and the
// maximum number of results from the given snapshot_id. It will create
// a snapshot if snapshot_id is empty.
message InternalSnapshotCopyRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  // Optional, a new snapshot will be created if it is empty.
  optional string snapshot_id = 2 [(gogoproto.nullable) = false, (gogoproto.customname) = "SnapshotID"];
  // Must be > 0.
  optional int64 max_results = 3 [(gogoproto.nullable) = false];
}

// An InternalSnapshotCopyResponse is the return value from the
// InternalSnapshotCopy() method.
message InternalSnapshotCopyResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  optional string snapshot_id = 2 [(gogoproto.nullable) = false, (gogoproto.customname) = "SnapshotID"];
  // Empty if no rows were scanned.
  repeated RawKeyValue rows = 3 [(gogoproto.nullable) = false];
}

// An InternalMergeRequest contains arguments to the InternalMerge() method. It
// specifies a key and a value which should be merged into the existing value at
// that key.
message InternalMergeRequest {
  optional RequestHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
  optional Value value = 2 [(gogoproto.nullable) = false];
}

// InternalMergeResponse is the response to an InternalMerge() operation.
message InternalMergeResponse {
  optional ResponseHeader header = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
}

// A ReadWriteCmdResponse is a union type containing instances of all
// mutating commands. Note that any entry added here must be handled
// in roachlib/db.cc in GetResponseHeader().
message ReadWriteCmdResponse {
  option (gogoproto.onlyone) = true;
  optional PutResponse put = 1;
  optional ConditionalPutResponse conditional_put = 2;
  optional IncrementResponse increment = 3;
  optional DeleteResponse delete = 4;
  optional DeleteRangeResponse delete_range = 5;
  optional EndTransactionResponse end_transaction = 6;
  optional ReapQueueResponse reap_queue = 7;
  optional EnqueueUpdateResponse enqueue_update = 8;
  optional EnqueueMessageResponse enqueue_message = 9;
  optional InternalHeartbeatTxnResponse internal_heartbeat_txn = 10;
  optional InternalPushTxnResponse internal_push_txn = 11;
  optional InternalResolveIntentResponse internal_resolve_intent = 12;
  optional InternalMergeResponse internal_merge = 13;
}

// An InternalRaftCommandUnion is the union of all commands which can be
// sent via raft.
message InternalRaftCommandUnion {
  option (gogoproto.onlyone) = true;
  // Non-batched external requests. This section is the same as RequestUnion.
  optional ContainsRequest contains = 1;
  optional GetRequest get = 2;
  optional PutRequest put = 3;
  optional ConditionalPutRequest conditional_put = 4;
  optional IncrementRequest increment = 5;
  optional DeleteRequest delete = 6;
  optional DeleteRangeRequest delete_range = 7;
  optional ScanRequest scan = 8;
  optional EndTransactionRequest end_transaction = 9;
  optional ReapQueueRequest reap_queue = 10;
  optional EnqueueUpdateRequest enqueue_update = 11;
  optional EnqueueMessageRequest enqueue_message = 12;

  // Other requests. Allow a gap in tag numbers so the previous list can
  // be copy/pasted from RequestUnion.
  optional BatchRequest batch = 30;
  optional InternalRangeLookupRequest internal_range_lookup = 31;
  optional InternalHeartbeatTxnRequest internal_heartbeat_txn = 32;
  optional InternalPushTxnRequest internal_push_txn = 33;
  optional InternalResolveIntentRequest internal_resolve_intent = 34;
  optional InternalSnapshotCopyRequest internal_snapshot_copy = 35;
  optional InternalMergeRequest internal_merge_response = 36;
}

// An InternalRaftCommand is a command which can be serialized and
// sent via raft.
message InternalRaftCommand {
  optional int64 raft_id = 2 [(gogoproto.nullable) = false, (gogoproto.customname) = "RaftID"];
  optional InternalRaftCommandUnion cmd = 3 [(gogoproto.nullable) = false];
}

// InternalValueType defines a set of string constants placed in the "tag" field
// of Value messages which are created internally. These are defined as a
// protocol buffer enumeration so that they can be used portably between our Go
// and C code.
enum InternalValueType {
    option (gogoproto.goproto_enum_prefix) = false;
    // _CR_TS is applied to values which contain TimeSeriesData.  This tag is
    // used by the RocksDB Merge Operator to perform a specialized merge for
    // this data.
    _CR_TS = 1;
}

// TimeSeriesPrecision is an enumeration which can describe the precision of the
// time at which data points are taken.  Currently, millisecond or second
// precision is available.
enum TimeSeriesPrecision {
    option (gogoproto.goproto_enum_prefix) = false;
    MILLISECONDS = 0;
    SECONDS = 1;
}

// TimeSeriesData contains time series data collected over a given interval of
// time. The data is represented as a variable number of distinct data points
// falling within the interval; each data point is a numeric value paired an
// offset from the start of the interval.
//
// Data points within a TimeSeriesData should correspond to samples of the same
// statistic at different point in times. Information about the statistic which
// is being sampled is encoded in the Key at which the TimeSeriesData is stored.
message TimeSeriesData {
    // Holds a wall time, expressed as a unix epoch time in seconds. This
    // represents the start of the interval.
    optional int64 start_timestamp = 1 [(gogoproto.nullable) = false];
    // The duration of the interval in seconds.
    optional int64 duration_in_seconds = 2 [(gogoproto.nullable) = false];
    // The precision of the samples within this data set.
    optional TimeSeriesPrecision sample_precision = 3 [(gogoproto.nullable) = false];
    // A set of data points which fall within the interval.
    repeated TimeSeriesDataPoint data = 4;
}

// A TimeSeriesDataPoint is a single point of numeric data sampled at particular
// time. Multiple TimeSeriesDataPoints are grouped into a single TimeSeriesData
// collection.
message TimeSeriesDataPoint {
    // Temporal offset from the "start_timestamp" of the TimeSeriesData
    // collection this data point is stored in. The units of this value are
    // determined by the value of the "sample_precision" field of the
    // TimeSeriesData collection.
    optional int32 offset = 2 [(gogoproto.nullable) = false];
    // Value field for integer samples. If this value is present, then
    // "value_float" must not be present.
    optional int64 value_int = 4;
    // Value field for floating point samples. If this value is present, then
    // "value_int" must not be set.
    optional float value_float = 5;
}
